# Shared behaviour of entities
const Entity = behaviour {
  set_pos: fn [&'e]({f32, f32}) -> void,
  read_pos: fn [&]() -> {f32, f32}
}

# A function with accepts a behaviour instead of a type
const movementSystem = (entity: &'e Entity) {
  let {x, y} = entity.read_pos()

  x += 10.0
  y += 15.0

  entity.set_pos({x, y})
}

# A record representing a player
const Player = record {
  pos: {f32, f32}
}

# Implementing Entity for player
def set_pos[p: &'e Player] = (pos: {f32, f32}) {
  p.pos = pos
}

def read_pos[p: &Player] = (): {f32, f32} {
  p.pos
}

# A record representing an enemy
const Enemy = record {
  pos: {f32, f32}
}

# Implementing Entity for enemy
def set_pos[e: &'e Enemy] = (pos) {
  e.pos = pos
}

def read_pos[e: &Enemy] = () {
  e.pos
}

# Instantiating enemy and player
let (
  player = Player{}
  enemy = Enemy{}
)

# Calling movementSystem on a player and enemy
movementSystem(&player)
movementSystem(&enemy)
