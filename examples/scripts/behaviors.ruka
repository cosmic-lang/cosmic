# Shared behaviour of entities
const Entity = behaviour{
  set_pos: fn ({f32, f32}) -> (),
  read_pos: fn () -> {f32, f32}
}

# A function with accepts a behaviour instead of a type
const movementSystem = (entity: &mut Entity) do 
  var {x, y} = entity.read_pos()

  x += 10.0
  y += 15.0

  entity.set_pos({x, y})
end

# A struct representing a player
const Player = struct{
  pos: {f32, f32}
}

# Implementing Entity for player
const set_pos(self: &mut Player) = (pos: {f32, f32}) {
  self.pos = pos
}

const read_pos(self: &Player) = (): int {
  self.pos
}

# A struct representing an enemy
const Enemy = struct{
  pos: {f32, f32}
}

# Implementing Entity for enemy
const set_pos(self: &mut Enemy) = (pos: {f32, f32}) {
  self.pos = pos
}

const read_pos(self: &Enemy) = (): int {
  self.pos
}

# Instanciating enemy and player
var (
  player = Player{}
  enemy = Enemy{}
)

# Calling movementSystem on a player and enemy
movementSystem(&mut player)
movementSystem(&mut enemy)
